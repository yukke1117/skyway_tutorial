"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RtcRpcApiClient = void 0;
const common_1 = require("@skyway-sdk/common");
const const_1 = require("./const");
const errors_1 = require("./errors");
const rpc_1 = require("./rpc");
const util_1 = require("./util");
const log = new common_1.Logger('packages/rtc-rpc-api-client/src/client.ts');
class RtcRpcApiClient {
    constructor(config) {
        var _a, _b, _c, _d, _e, _f;
        this.config = config;
        this.closed = false;
        this._domain = (_a = this.config.domain) !== null && _a !== void 0 ? _a : const_1.defaultDomain;
        this._secure = (_b = this.config.secure) !== null && _b !== void 0 ? _b : true;
        this._token = this.config.token;
        /**@private */
        this._rpc = new rpc_1.RPC();
        this._subscribingChannelEvents = new Set();
        this._subscribingChannelVersions = {};
        this._httpClient = new common_1.HttpClient(`http${this.config.secure ? 's' : ''}://${this.config.domain}`);
        this._reconnectCount = 0;
        this._reconnectLimit = const_1.MaxRetry;
        this._events = new common_1.Events();
        this.onEvent = this._events.make();
        this.onFatalError = this._events.make();
        this.onClose = this._events.make();
        this.onReconnected = this._events.make();
        common_1.Logger.level = (_d = (_c = config.log) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : common_1.Logger.level;
        common_1.Logger.format = (_f = (_e = config.log) === null || _e === void 0 ? void 0 : _e.format) !== null && _f !== void 0 ? _f : common_1.Logger.format;
        log.debug('RtcRpcApiClient spawned', config);
        this._rpc.onNotify.add((notify) => {
            if (notify.method === 'channelEventNotification') {
                const event = notify.params;
                this._subscribingChannelVersions[event.data.channel.id] =
                    event.data.channel.version;
                this.onEvent.emit({ channelId: event.data.channel.id, event });
            }
        });
        this._rpc.onDisconnected.add(() => __awaiter(this, void 0, void 0, function* () {
            if (this._rpc.negotiated &&
                !this._rpc.closed &&
                !this._rpc.reconnecting) {
                yield this._reconnect();
            }
        }));
        this._rpc.onFatalError.once((e) => {
            log.error('fatal error', e);
            this.onFatalError.emit(e);
            this.close();
        });
    }
    get token() {
        return this._token;
    }
    _reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._reconnectCount >= this._reconnectLimit) {
                this._rpc.onFatalError.emit((0, util_1.createError)({
                    operationName: 'RtcRpcApiClient._reconnect',
                    info: {
                        name: 'failed to reconnect',
                        detail: '_reconnectLimit exceeded',
                        solution: '',
                    },
                    path: log.prefix,
                }));
                this.close();
                return;
            }
            this._rpc.reconnecting = true;
            log.warn('[start] reconnect', (0, util_1.createWarnPayload)({
                operationName: 'RtcRpcApiClient._reconnect',
                detail: 'reconnect start',
                payload: {
                    reconnectCount: this._reconnectCount,
                    limit: this._reconnectLimit,
                },
            }));
            this._reconnectCount++;
            const backOffTime = Math.pow(this._reconnectCount, 2) * 100 +
                Math.pow(this._reconnectCount, 2) * 100 * Math.random();
            yield new Promise((r) => setTimeout(r, backOffTime));
            try {
                yield this.connect().catch((err) => {
                    log.warn(`[failed] reconnect rtc api`, (0, util_1.createWarnPayload)({
                        operationName: 'RtcRpcApiClient._reconnect',
                        detail: 'connect rpc failed',
                        payload: {
                            reconnectCount: this._reconnectCount,
                        },
                    }), err);
                    throw err;
                });
                this._rpc.reconnecting = false;
                this._reconnectCount = 0;
                this._rpc.resolvePendingRequests();
                yield Promise.all([...this._subscribingChannelEvents].map((s) => __awaiter(this, void 0, void 0, function* () {
                    const [appId, channelId] = s.split(':');
                    const offset = this._subscribingChannelVersions[channelId];
                    yield this.subscribeChannelEvents({
                        appId,
                        channelId,
                        offset,
                    });
                }))).catch((e) => {
                    log.warn('subscribeChannelEvents failed', (0, util_1.createWarnPayload)({
                        operationName: 'RtcRpcApiClient._reconnect',
                        detail: 'subscribeChannelEvents failed',
                        payload: {
                            reconnectCount: this._reconnectCount,
                        },
                    }), e);
                    throw e;
                });
                log.warn('[end] reconnect', (0, util_1.createWarnPayload)({
                    operationName: 'RtcRpcApiClient._reconnect',
                    detail: 'reconnect finished',
                    payload: {
                        reconnectCount: this._reconnectCount,
                    },
                }));
                this.onReconnected.emit();
            }
            catch (error) {
                log.warn('[failed] reconnect', (0, util_1.createWarnPayload)({
                    operationName: 'RtcRpcApiClient._reconnect',
                    detail: 'reconnect failed',
                    payload: {
                        reconnectCount: this._reconnectCount,
                    },
                }), error);
                yield this._reconnect();
            }
        });
    }
    updateToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('token update', { token });
            this._token = token;
            yield this._updateAuthToken();
        });
    }
    close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        log.debug('closed');
        this._rpc.close();
        this.onClose.emit();
        this._events.dispose();
    }
    health() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this._httpClient.get('/health');
            return response;
        });
    }
    /** @throws {@link SkyWayError} */
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('connect to rtc api rpc', this._domain);
            yield this._rpc
                .connect({
                domain: this._domain,
                token: this.token,
                secure: this._secure,
            })
                .catch((e) => {
                throw (0, util_1.createError)({
                    operationName: 'RtcRpcApiClient.connect',
                    info: errors_1.errors.failedToConnectRtcAPI,
                    error: e,
                    path: log.prefix,
                });
            });
        });
    }
    _channelSubscribed(appId, channelId) {
        this._subscribingChannelEvents.add(appId + ':' + channelId);
        log.debug('_channelSubscribed', {
            appId,
            channelId,
            _subscribingChannelEvents: [...this._subscribingChannelEvents],
        });
    }
    _isSubscribingChannel(appId, channelId) {
        return this._subscribingChannelEvents.has(appId + ':' + channelId);
    }
    createChannel({ name, metadata, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { channel } = yield this._rpc.request('createChannel', {
                name,
                metadata,
                appId,
                authToken: this.token,
            });
            this._channelSubscribed(appId, channel.id);
            return channel;
        });
    }
    findOrCreateChannel({ name, metadata, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { channel } = yield this._rpc.request('findOrCreateChannel', {
                name,
                metadata,
                appId,
                authToken: this.token,
            });
            this._channelSubscribed(appId, channel.id);
            return channel;
        });
    }
    getChannel({ appId, id }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('getChannel', {
                id,
                appId,
                authToken: this.token,
            });
            // getChannelは暗黙的にEventがsubscribeされない
            if (!this._isSubscribingChannel(appId, id)) {
                this._channelSubscribed(appId, id);
                yield this.subscribeChannelEvents({
                    appId,
                    channelId: id,
                    offset: res.channel.version,
                });
            }
            return res.channel;
        });
    }
    getChannelByName({ name, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('getChannelByName', {
                name,
                appId,
                authToken: this.token,
            });
            const channelId = res.channel.id;
            // getChannelByNameは暗黙的にEventがsubscribeされない
            if (!this._isSubscribingChannel(appId, channelId)) {
                this._channelSubscribed(appId, channelId);
                yield this.subscribeChannelEvents({
                    appId,
                    channelId,
                    offset: res.channel.version,
                });
            }
            return res.channel;
        });
    }
    deleteChannel({ id, appId }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('deleteChannel', {
                id,
                appId,
                authToken: this.token,
            });
        });
    }
    updateChannelMetadata({ id, metadata, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('updateChannelMetadata', {
                id,
                metadata,
                appId,
                authToken: this.token,
            });
        });
    }
    addMember({ channelId, name, metadata, subscribeChannelEvents, appId, ttlSec, subtype, type, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('addMember', {
                channelId,
                name,
                metadata,
                subscribeChannelEvents,
                appId,
                ttlSec: ttlSec && parseInt(ttlSec.toString()),
                authToken: this.token,
                subtype,
                type,
            });
            return res;
        });
    }
    updateMemberTtl(args, backoff = new common_1.BackOff({ times: 8 })) {
        return __awaiter(this, void 0, void 0, function* () {
            const { appId, channelId, memberId, ttlSec } = args;
            try {
                yield this._rpc.request('updateMemberTtl', {
                    appId,
                    channelId,
                    memberId,
                    ttlSec: ttlSec && parseInt(ttlSec.toString()),
                    authToken: this.token,
                });
            }
            catch (e) {
                if (!backoff.exceeded) {
                    log.warn('retry updateMemberTtl', (0, util_1.createWarnPayload)({
                        operationName: 'RtcRpcApiClient.updateMemberTtl',
                        detail: 'retry updateMemberTtl',
                        appId,
                        channelId,
                        memberId,
                        payload: { backoff: backoff.count },
                    }), e);
                    yield backoff.wait();
                    yield this.updateMemberTtl(args, backoff);
                }
                else {
                    const error = new common_1.SkyWayError({
                        path: log.prefix,
                        info: errors_1.errors.failedToUpdateMemberTTL,
                        error: e,
                    });
                    throw error;
                }
            }
        });
    }
    updateMemberMetadata({ channelId, memberId, metadata, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('updateMemberMetadata', {
                channelId,
                memberId,
                metadata,
                appId,
                authToken: this.token,
            });
        });
    }
    leaveChannel({ channelId, id, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('removeMember', {
                channelId,
                id,
                appId,
                authToken: this.token,
            });
        });
    }
    publishStream({ appId, channelId, publisherId, contentType, metadata, origin, codecCapabilities, encodings, isEnabled, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('publishStream', {
                channelId,
                publisherId,
                contentType: contentType[0].toUpperCase() + contentType.slice(1),
                metadata,
                origin,
                codecCapabilities,
                encodings: encodings === null || encodings === void 0 ? void 0 : encodings.map((e) => ({
                    id: e.id,
                })),
                isEnabled,
                appId,
                authToken: this.token,
            });
            return { publicationId: res.id };
        });
    }
    disablePublication({ channelId, publicationId, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('disablePublication', {
                channelId,
                appId,
                publicationId,
                authToken: this.token,
            });
        });
    }
    enablePublication({ channelId, publicationId, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('enablePublication', {
                channelId,
                appId,
                publicationId,
                authToken: this.token,
            });
        });
    }
    updatePublicationMetadata({ channelId, publicationId, appId, metadata, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('updatePublicationMetadata', {
                channelId,
                publicationId,
                metadata,
                appId,
                authToken: this.token,
            });
        });
    }
    unpublishStream({ channelId, publicationId, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('unpublishStream', {
                channelId,
                publicationId,
                appId,
                authToken: this.token,
            });
        });
    }
    subscribeStream({ channelId, subscriberId, publicationId, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._rpc.request('subscribeStream', {
                channelId,
                subscriberId,
                publicationId,
                appId,
                authToken: this.token,
            });
            return { subscriptionId: res.id };
        });
    }
    unsubscribeStream({ channelId, subscriptionId, appId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('unsubscribeStream', {
                channelId,
                subscriptionId,
                appId,
                authToken: this.token,
            });
        });
    }
    /**
     * @returns Date.now()
     */
    getServerUnixtime(args, backoff = new common_1.BackOff({ times: 8 })) {
        return __awaiter(this, void 0, void 0, function* () {
            const { appId } = args;
            try {
                const res = yield this._rpc.request('getServerUnixtime', {
                    appId,
                    authToken: this.token,
                });
                return res.unixtime;
            }
            catch (error) {
                if (!backoff.exceeded) {
                    log.warn((0, util_1.createWarnPayload)({
                        operationName: 'RtcRpcApiClient.getServerUnixtime',
                        detail: 'retry getServerUnixtime',
                        appId,
                        payload: { backoff: backoff.count },
                    }), error);
                    yield backoff.wait();
                    return this.getServerUnixtime(args, backoff);
                }
                else {
                    throw error;
                }
            }
        });
    }
    /**@description [japanese] 現在のセッションに関連付けられている SkyWayAuthToken を更新します */
    _updateAuthToken() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._rpc.request('updateAuthToken', {
                authToken: this.token,
            });
        });
    }
    /**
     * @description
     * - 指定した Channel の Event を Subscribe していなければ Event が生じるたびに Notification が送られるようになります。
     * - Subscribeした時点で、指定された offset (default to 0) の version から、最新の version までのイベントが送られます。
     */
    subscribeChannelEvents({ appId, channelId, offset, }) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                log.debug('[start] subscribeChannelEvents', { offset });
                yield this._rpc.request('subscribeChannelEvents', {
                    appId,
                    authToken: this.token,
                    channelId,
                    offset,
                });
                log.debug('[end] subscribeChannelEvents', { offset });
            }
            catch (error) {
                if (error instanceof common_1.SkyWayError &&
                    error.info.name === errors_1.errors.connectionDisconnected.name) {
                    log.warn('reconnect happened while subscribeChannelEvents. retry', (0, util_1.createWarnPayload)({
                        operationName: 'RtcRpcApiClient.subscribeChannelEvents',
                        detail: 'reconnect happened while subscribeChannelEvents. retry',
                        appId,
                        channelId,
                        payload: { offset },
                    }), error);
                    yield this.subscribeChannelEvents({ appId, channelId, offset });
                }
                else {
                    log.error('[failed] subscribeChannelEvents', (0, util_1.createError)({
                        operationName: 'RtcRpcApiClient.subscribeChannelEvents',
                        info: Object.assign(Object.assign({}, errors_1.errors.internalError), { detail: 'subscribeChannelEvents failed' }),
                        path: log.prefix,
                        error,
                        payload: { offset },
                        appId,
                        channelId,
                    }));
                    throw error;
                }
            }
        });
    }
}
exports.RtcRpcApiClient = RtcRpcApiClient;
//# sourceMappingURL=client.js.map