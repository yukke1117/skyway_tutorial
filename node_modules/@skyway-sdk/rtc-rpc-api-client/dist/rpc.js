"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPC = void 0;
const common_1 = require("@skyway-sdk/common");
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
const uuid_1 = require("uuid");
const const_1 = require("./const");
const errors_1 = require("./errors");
const util_1 = require("./util");
const log = new common_1.Logger('packages/rtc-rpc-api-client/src/rpc.ts');
class RPC {
    constructor() {
        this._id = (0, uuid_1.v4)();
        this.closed = false;
        this.negotiated = false;
        this._reconnecting = false;
        this._pendingRequests = [];
        this._events = new common_1.Events();
        this._onMessage = this._events.make();
        this.onNotify = this._events.make();
        this.onFatalError = this._events.make();
        this.onDisconnected = this._events.make();
        this.onClosed = this._events.make();
        this._send = (request) => new Promise((r, f) => __awaiter(this, void 0, void 0, function* () {
            // 非同期化
            yield new Promise((r) => setTimeout(r, 0));
            if (this._ws.readyState !== this._ws.OPEN) {
                f((0, util_1.createError)({
                    operationName: 'RPC._send',
                    info: Object.assign(Object.assign({}, errors_1.errors.internalError), { detail: 'wrong state' }),
                    path: log.prefix,
                    payload: {
                        request,
                        wsReadyState: wsStates[this._ws.readyState],
                    },
                }));
                return;
            }
            this._ws.send(JSON.stringify(request), (error) => {
                if (error) {
                    throw f((0, util_1.createError)({
                        operationName: 'RPC._send',
                        info: Object.assign(Object.assign({}, errors_1.errors.internalError), { detail: 'failed to send rpc message' }),
                        path: log.prefix,
                        error,
                    }));
                }
            });
            r();
        }));
    }
    set reconnecting(b) {
        this._reconnecting = b;
    }
    get reconnecting() {
        return this._reconnecting;
    }
    connect({ domain, token, secure, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const subProtocol = token;
            this._ws = new isomorphic_ws_1.default(`${secure ? 'wss' : 'ws'}://${domain}/ws`, subProtocol);
            this._ws.onmessage = (ev) => {
                this._onMessage.emit(JSON.parse(ev.data));
            };
            this._ws.onclose = () => __awaiter(this, void 0, void 0, function* () {
                log.debug('websocket closed', { id: this._id });
                this.onDisconnected.emit();
            });
            this._onMessage.add((msg) => {
                if (isNotifyMessage(msg)) {
                    this.onNotify.emit(msg);
                }
            });
            const error = yield new Promise((r, f) => {
                const timeout = setTimeout(() => {
                    f((0, util_1.createError)({
                        operationName: 'RPC.connect',
                        info: Object.assign(Object.assign({}, errors_1.errors.timeout), { detail: 'ws.open' }),
                        path: log.prefix,
                    }));
                }, 5000);
                this._ws.onerror = (e) => {
                    f((0, util_1.createError)({
                        operationName: 'RPC.connect',
                        info: errors_1.errors.websocketConnectionFailure,
                        path: log.prefix,
                        error: e,
                    }));
                };
                this._ws.onopen = () => {
                    clearTimeout(timeout);
                    r();
                };
            }).catch((e) => e);
            if (error) {
                throw error;
            }
            this.negotiated = true;
        });
    }
    close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        log.debug('closed');
        this._ws.close();
        this.onClosed.emit();
        this._events.dispose();
    }
    resolvePendingRequests() {
        log.debug('resolve pendingRequests', [...this._pendingRequests]);
        this._pendingRequests.forEach((req) => __awaiter(this, void 0, void 0, function* () {
            yield this._send(req);
        }));
        this._pendingRequests = [];
    }
    /**
     * @throws {@link SkyWayError}
     */
    request(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.closed) {
                throw (0, util_1.createError)({
                    operationName: 'RPC.request',
                    info: Object.assign(Object.assign({}, errors_1.errors.internalError), { detail: 'rpc closed' }),
                    path: log.prefix,
                    payload: { method, params, id: this._id },
                });
            }
            let promiseResolved = false;
            try {
                const request = buildRequest(method, params);
                const handleMessage = () => __awaiter(this, void 0, void 0, function* () {
                    return (yield this._onMessage
                        .watch((msg) => msg.id === request.id, const_1.rpcTimeout)
                        .catch(() => {
                        if (promiseResolved) {
                            return;
                        }
                        throw (0, util_1.createError)({
                            operationName: 'RPC.request',
                            info: Object.assign(Object.assign({}, errors_1.errors.timeout), { detail: 'rpc request timeout' }),
                            path: log.prefix,
                            payload: {
                                rpcTimeout: const_1.rpcTimeout,
                                method,
                                params,
                                wsReadyState: wsStates[this._ws.readyState],
                                id: this._id,
                            },
                        });
                    }));
                });
                const pendingRequest = () => __awaiter(this, void 0, void 0, function* () {
                    log.warn('[start] reconnecting. pending request', (0, util_1.createWarnPayload)({
                        operationName: 'RPC.request',
                        detail: '[start] reconnecting. pending request',
                        payload: { request, id: this._id },
                    }));
                    // 再接続後に再送する
                    this._pendingRequests.push(request);
                    const message = yield Promise.race([
                        handleMessage(),
                        this.onFatalError.asPromise(const_1.rpcTimeout + 100).then((e) => {
                            if (!promiseResolved) {
                                log.error('[failed] reconnecting. pending request', (0, util_1.createError)({
                                    operationName: 'RPC.request',
                                    info: Object.assign(Object.assign({}, errors_1.errors.internalError), { detail: 'onFatalError while request' }),
                                    path: log.prefix,
                                }), e);
                            }
                            throw e;
                        }),
                    ]);
                    promiseResolved = true;
                    log.warn('[end] reconnecting. pending request', (0, util_1.createWarnPayload)({
                        operationName: 'RPC.request',
                        detail: '[end] reconnecting. pending request',
                        payload: { request, id: this._id },
                    }));
                    return message;
                });
                let message;
                if (!this._reconnecting) {
                    this._send(request).catch((e) => {
                        log.error('send error', e);
                    });
                    message = yield Promise.race([
                        handleMessage(),
                        // 返信待ち中に接続が切れた場合
                        (() => __awaiter(this, void 0, void 0, function* () {
                            yield this.onDisconnected.asPromise(const_1.rpcTimeout + 100);
                            if (promiseResolved) {
                                return {};
                            }
                            try {
                                const message = yield pendingRequest();
                                log.warn((0, util_1.createWarnPayload)({
                                    operationName: 'request.pendingRequest',
                                    detail: 'success to handle disconnected',
                                }));
                                return message;
                            }
                            catch (error) {
                                throw (0, util_1.createError)({
                                    operationName: 'RPC.request',
                                    info: errors_1.errors.connectionDisconnected,
                                    path: log.prefix,
                                    error,
                                });
                            }
                        }))(),
                        this.onFatalError.asPromise(const_1.rpcTimeout + 100).then((e) => {
                            if (promiseResolved) {
                                return {};
                            }
                            throw (0, util_1.createError)({
                                operationName: 'RPC.request',
                                info: Object.assign(Object.assign({}, errors_1.errors.internalError), { detail: 'onFatalError while requesting' }),
                                path: log.prefix,
                                error: e,
                            });
                        }),
                        this.onClosed.asPromise(const_1.rpcTimeout + 100).then(() => {
                            if (promiseResolved) {
                                return {};
                            }
                            throw (0, util_1.createError)({
                                operationName: 'RPC.request',
                                info: errors_1.errors.onClosedWhileRequesting,
                                path: log.prefix,
                                payload: { method, params },
                            });
                        }),
                    ]);
                    promiseResolved = true;
                }
                else {
                    message = yield pendingRequest();
                }
                if (message.error) {
                    log.warn('[failed] request ', { message, method, params });
                    throw (0, util_1.createError)({
                        operationName: 'RPC.request',
                        info: Object.assign(Object.assign({}, errors_1.errors.rpcResponseError), { detail: method, error: message.error }),
                        payload: { message, method, params },
                        path: log.prefix,
                    });
                }
                return message.result;
            }
            catch (error) {
                promiseResolved = true;
                throw error;
            }
        });
    }
    notify(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = buildRequest(method, params, true);
            yield this._send(request);
        });
    }
    batch(requests) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = requests.map(({ method, params }) => buildRequest(method, params));
            this._send(messages).catch((e) => {
                throw e;
            });
            const responses = yield Promise.all(messages.map(({ id }) => __awaiter(this, void 0, void 0, function* () {
                const message = (yield this._onMessage.watch((msg) => msg.id === id, const_1.rpcTimeout));
                return message;
            })));
            return responses;
        });
    }
}
exports.RPC = RPC;
const buildRequest = (method, params, notify) => {
    if (notify) {
        return { jsonrpc: '2.0', method, params };
    }
    const id = (0, uuid_1.v4)();
    return { jsonrpc: '2.0', method, params, id };
};
const isNotifyMessage = (msg) => {
    const notify = msg;
    if (notify.method && notify.id == undefined) {
        return true;
    }
    return false;
};
const wsStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
//# sourceMappingURL=rpc.js.map