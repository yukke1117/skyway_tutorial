"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.logLevelTypes = void 0;
/**
 * @description [japanese]
 * 以下のいずれかを指定可能
 * - disable: ログの出力を無効化する。
 * - error: 回復不能なエラーに関する情報を出力する。
 * - warn: SDK 内部で発生した、一時的なエラーに関する情報を出力する。基本的には SDK が内部でリトライ処理を行うことで回復する。
 * - info: SDK が提供しているメソッドの呼び出しに関する情報を出力する。
 * - debug: SDK の内部のメソッド呼び出しや、リクエスト・レスポンスに関する情報など、最も詳細なログを出力する。
 */
exports.logLevelTypes = [
    'disable',
    'error',
    'warn',
    'info',
    'debug',
];
class Logger {
    /**@internal */
    constructor(prefix) {
        /**@internal */
        this.debug = (...msg) => {
            this._log('debug', ...msg);
            return Date.now();
        };
        /**@internal */
        this.info = (...msg) => {
            this._log('info', ...msg);
            return Date.now();
        };
        /**@internal */
        this.warn = (...msg) => {
            this._log('warn', ...msg);
        };
        /**@internal */
        this.error = (...msg) => {
            this._log('error', ...msg);
        };
        /**@internal */
        this.elapsed = (timestamp, ...msg) => {
            const elapsed = Date.now() - timestamp;
            this._log('info', `elapsed ms:${elapsed}`, ...msg);
        };
        this.prefix = prefix;
    }
    _log(level, ...msg) {
        const logType = exports.logLevelTypes.indexOf(level);
        const logLevel = exports.logLevelTypes.indexOf(Logger.level);
        if (logLevel >= logType) {
            const timestamp = new Date(Date.now() + 60 * 9 * 60000).toISOString() + '+JST';
            const parsed = [this.prefix, ...msg].map((m) => {
                if (m instanceof Error) {
                    if (m.toJSON) {
                        return m.toJSON();
                    }
                    return { name: m.name, message: m.message, stack: m.stack };
                }
                if (typeof m === 'object') {
                    try {
                        return JSON.parse(JSON.stringify(m));
                    }
                    catch (error) {
                        return 'json error';
                    }
                }
                return m;
            });
            msg = parsed;
            let log = [timestamp, level, ...msg];
            if (Logger.format === 'string') {
                log = [timestamp + ' ' + level + ' ' + JSON.stringify(msg)];
            }
            switch (level) {
                case 'debug':
                    console.debug(...log);
                    break;
                case 'info':
                    console.info(...log);
                    break;
                case 'warn':
                    console.warn(...log);
                    break;
                case 'error':
                    console.error(...log);
                    break;
            }
            Logger.onLog({ id: Logger.id, timestamp, level, message: msg });
        }
    }
    /**@internal */
    createBlock(info) {
        return {
            warn: (...msg) => {
                this.warn(Object.assign({}, info), ...msg);
            },
            debug: (...msg) => {
                this.debug(Object.assign({}, info), ...msg);
            },
            info: (...msg) => {
                this.info(Object.assign({}, info), ...msg);
            },
            error: (...msg) => {
                this.error(Object.assign({}, info), ...msg);
            },
        };
    }
}
exports.Logger = Logger;
Logger.level = 'error';
Logger.format = 'object';
Logger.onLog = () => { };
/**@internal */
Logger.id = Math.random().toString().slice(2, 7);
//# sourceMappingURL=logger.js.map