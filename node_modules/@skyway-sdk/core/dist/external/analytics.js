"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyticsSession = exports.setupAnalyticsSession = void 0;
const analytics_client_1 = require("@skyway-sdk/analytics-client");
const common_1 = require("@skyway-sdk/common");
const context_1 = require("../context");
const errors_1 = require("../errors");
const util_1 = require("../util");
const log = new common_1.Logger('packages/core/src/external/analytics.ts');
function setupAnalyticsSession(context, channel, memberDto) {
    return __awaiter(this, void 0, void 0, function* () {
        const { analyticsService } = context.config;
        const client = new analytics_client_1.AnalyticsClient({
            token: context.authTokenString,
            channelId: channel.id,
            channelName: channel.name,
            memberId: memberDto.id,
            memberName: memberDto.name,
            sdkVersion: context_1.SkyWayContext.version, // coreパッケージのバージョンを引き渡す
        }, {
            logger: {
                error: (message, error) => __awaiter(this, void 0, void 0, function* () {
                    log.error(`AnalyticsClient error: ${message}`, (0, util_1.createError)({
                        operationName: 'AnalyticsClient.logger',
                        context,
                        info: Object.assign(Object.assign({}, errors_1.errors.internal), { detail: 'AnalyticsClient error' }),
                        error,
                        path: log.prefix,
                        channel,
                    }));
                }),
                debug: (message, ...optionalParams) => {
                    log.debug('[analytics]:', message, ...optionalParams);
                },
                warn: (message, ...optionalParams) => {
                    log.warn('[analytics]:', message, ...optionalParams);
                },
            },
            analyticsLoggingServerDomain: analyticsService.domain,
            secure: analyticsService.secure,
        });
        const analyticsSession = new AnalyticsSession(client, context);
        analyticsSession.connectWithTimeout().catch((error) => {
            analyticsSession.close();
            log.error(`AnalyticsClient error: ${error.message}`, (0, util_1.createError)({
                operationName: 'AnalyticsClient.logger',
                context,
                info: Object.assign(Object.assign({}, errors_1.errors.internal), { detail: 'AnalyticsClient error' }),
                error,
                path: log.prefix,
                channel,
            }));
            analyticsSession.onConnectionFailed.emit({});
        });
        return analyticsSession;
    });
}
exports.setupAnalyticsSession = setupAnalyticsSession;
class AnalyticsSession {
    constructor(client, context) {
        this.client = client;
        this.context = context;
        this.onConnectionFailed = new common_1.Event();
        this.onConnectionStateChanged = new common_1.Event();
        this.onMessage = new common_1.Event();
        this._isClosed = false;
        this._listen();
        context._onTokenUpdated.add((token) => {
            this.client.setNewSkyWayAuthToken(token);
        });
    }
    _listen() {
        this.client.onConnectionFailed.addOneTimeListener(() => {
            this.onConnectionFailed.emit({});
        });
        this.client.onConnectionStateChanged.addListener((state) => {
            if (state === 'closed' && !this.isClosed() && this.client.isClosed()) {
                this.close();
            }
            this.onConnectionStateChanged.emit(state);
        });
    }
    get connectionState() {
        return this.client.connectionState;
    }
    _connect() {
        return __awaiter(this, void 0, void 0, function* () {
            log.debug('[start] connect analyticsService');
            yield this.client
                .connect()
                .then(() => {
                log.debug('[end] connect analyticsService');
            })
                .catch((error) => {
                this.close();
                log.debug('[end] failed connect analyticsService: also unreachable to server');
                log.error(`AnalyticsClient error: ${error.message}`, (0, util_1.createError)({
                    operationName: 'AnalyticsClient.logger',
                    info: Object.assign(Object.assign({}, errors_1.errors.internal), { detail: 'AnalyticsClient error' }),
                    error,
                    path: log.prefix,
                }));
                this.onConnectionFailed.emit({});
            });
            return;
        });
    }
    connectWithTimeout() {
        return __awaiter(this, void 0, void 0, function* () {
            let connectTimeout;
            const timeoutPromise = new Promise((_, reject) => {
                connectTimeout = setTimeout(() => {
                    log.debug('[end] failed connect analyticsService: no initial response from the server');
                    reject(new Error('failed connect analyticsService'));
                }, 30 * 1000);
            });
            const firstConnectionFailedPromise = new Promise((resolve, _) => {
                this.client.onAnalyticsNotEnabledError.addOneTimeListener((data) => {
                    log.warn(`[end] failed connect analyticsService: ${data.reason}`);
                    resolve();
                });
            });
            return Promise.race([
                this._connect(),
                timeoutPromise,
                firstConnectionFailedPromise,
            ]).finally(() => {
                clearTimeout(connectTimeout);
            });
        });
    }
    close() {
        this._isClosed = true;
        this.onConnectionFailed.removeAllListeners();
        this.onConnectionStateChanged.removeAllListeners();
        this.onMessage.removeAllListeners();
    }
    isClosed() {
        return this._isClosed;
    }
}
exports.AnalyticsSession = AnalyticsSession;
//# sourceMappingURL=analytics.js.map